First of all, we would like to thank all reviewers for their constructive feedback.
We hope that we get the chance to incorporate it into our paper.

Reviewer specific responses:

Reviewer #1
In 11. Reasons to Reject you asked for a comparison with Contraction Hierarchies running times.
We had hoped that lines 531 to 539 would address this sufficiently.
However, we did not provide any CH query times.
This is definitely something that we should improve.
We conducted the experiment and CH queries take on average 0.163ms in our experiments.
This confirms our statement that CH-Potentials converge gracefully to a CH.
If we get the opportunity, we would add this information to the paragraph.

In 13. Questions for the Authors you asked how we can prove the flexibility of our algorithm.
The flexibility of our approach is shown by the numerous problem settings and extensions that our approach can handle.
For each of these problem settings there are often entire lines of research with several papers to extend algorithms like CH to these settings.
CH-Potentials can handle all of these basically without modification and with very little implementation complexity.


Reviewer #2
In 13. Questions for the Authors you ask how the query weights are provided.
This very much depends on the application.
We choose the w_q formulation as a somewhat simplified formalization for the paper.
But the core strength of CH-Potentials is that w_q can be basically anything (a modified weight, a time-dependent function, a weight from an expanded graph, ...) and and can be provided in a number of different ways depending on the application.

For example, in the case of turn costs, w_q really is two edges from the turn-expanded graph (which is in fact known at preprocessing time).
But instead of reengineering CH/CCH preprocessing to mitigate the slowdown for preprocessing on the expanded graph [cite, cite] we just compute a CH on the original graph and run A* on the expanded graph.

In the time-dependent (traffic predictions) case, w_q is a function (also known at preprocessing time).
However adapting CH [cite]/CCH [cite]/CRP [cite] preprocessing to this setting proved to be very challenging (computing the travel time functions for shortcuts is quite involved and expensive. This is also a reason, why we skip over nodes instead of using shortcuts like Goldberg for Core-ALT).
For CH-Potentials, we just need to compute a CH on the lower bound graph and run A* on the time-dependent graph.

In the live-traffic scenario there are two ways, that w_q could be provided.
When w_q is an array in memory which would be constantly modified between queries, CRP/CCH would not fare very well, because one would need to run the customization for every query - which would take a couple of seconds per query - even with parallelization.
However, when w_q is provided as a completely new set of weights between a bigger number of queries, than CRP/CCH would indeed be a better choice for a practical application.
But this is not a weakness of CH-Potentials.
In fact, it is completely possible to replace the CH in CH-Potentials with a CCH to combine the benefits of customization with the flexibility of CH-Potentials.
This is actually implemented in our code (see Supplementary Material code/rust_road_router/engine/src/algo/ch_potentials.rs) and we also performed experiments with CCH-Potentials, but did not report the results due to space constraints and to keep the paper simpler.


Reviewer #3
Preprocessing

Reviewer #4
In 11. Reasons to Reject you asked for using more/different road networks.
In fact, we also performed experiments on other networks (including the standard DIMACs Europe benchmark instance) but the results did not provide any additional insights.
Thus, and due to the constrained space, we omitted them.
Adding them again would be easily possible, if this helps.

Thank you for the feedback in 12.
In case we get the opportunity, we will try make it clearer where our contribution starts.
Regarding citations for section 5: We are only aware of the work in [Topocore].
Which papers were we missing?

Regarding the question from In 13. Questions for the Authors:
1. Yes, the approach can be generalized to degree N
2. We do not think that its worthwhile due to the reasons state in [Topocore]
3. Yes, the benefit is graph specific: we can only skip low degree nodes if there are any. However, due to the reasons discussed in [Topocore], skipping nodes of degree higher than 3 should never pay off.

General
  Reproducibility

Loading graph ... done [9040ms]
Undirecting graph ... done [2980ms]
Computing order ... done [1685ms]
Checking if order valid ... done [84ms]
Saving order ... done [1152ms]
Testing if correctly saved ... done [49ms]
