
\documentclass[a4paper,UKenglish,cleveref, autoref]{lipics-v2019}
%This is a template for producing LIPIcs articles.
%See lipics-manual.pdf for further information.
%for A4 paper format use option "a4paper", for US-letter use option "letterpaper"
%for british hyphenation rules use option "UKenglish", for american hyphenation rules use option "USenglish"
%for section-numbered lemmas etc., use "numberwithinsect"
%for enabling cleveref support, use "cleveref"
%for enabling cleveref support, use "autoref"

\usepackage[algo2e,vlined]{algorithm2e}

%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

\bibliographystyle{plainurl}% the mandatory bibstyle

\title{Dummy title} %TODO Please add

\titlerunning{Dummy short title}%optional, please use if title is longer than one line

\author{Ben Strasser}{Dummy University Computing Laboratory, [optional: Address], Country \and My second affiliation, Country \and \url{http://www.myhomepage.edu} }{johnqpublic@dummyuni.org}{https://orcid.org/0000-0002-1825-0097}{(Optional) author-specific funding acknowledgements}%TODO mandatory, please use full name; only 1 author per \author macro; first two parameters are mandatory, other parameters can be empty. Please provide at least the name of the affiliation and the country. The full address is optional

\author{Tim Zeitz}{Institute of Theoretical Informatics, Algorithmics I, Karlsruhe Institute of Technology, Germany}{tim.zeitz@kit.edu}{}{}

\authorrunning{B. Strasser and T. Zeitz}%TODO mandatory. First: Use abbreviated first/middle names. Second (only in severe cases): Use first author plus 'et al.'

\Copyright{Ben Strasser and Tim Zeitz}%TODO mandatory, please use full first names. LIPIcs license is "CC-BY";  http://creativecommons.org/licenses/by/3.0/

\ccsdesc[500]{Theory of computation~Shortest paths}
% \ccsdesc[500]{General and reference}%TODO mandatory: Please choose ACM 2012 classifications from https://dl.acm.org/ccs/ccs_flat.cfm

\keywords{Dummy keyword}%TODO mandatory; please add comma-separated list of keywords

% \category{}%optional, e.g. invited paper

% \relatedversion{}%optional, e.g. full version hosted on arXiv, HAL, or other respository/website
%\relatedversion{A full version of the paper is available at \url{...}.}

% \supplement{}%optional, e.g. related research data, source code, ... hosted on a repository like zenodo, figshare, GitHub, ...

%\funding{(Optional) general funding statement \dots}%optional, to capture a funding statement, which applies to all authors. Please enter author specific funding statements as fifth argument of the \author macro.

% \acknowledgements{I want to thank \dots}%optional

%\nolinenumbers %uncomment to disable line numbering

%\hideLIPIcs  %uncomment to remove references to LIPIcs series (logo, DOI, ...), e.g. when preparing a pre-final version to be uploaded to arXiv or another public repository

%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\EventEditors{John Q. Open and Joan R. Access}
\EventNoEds{2}
\EventLongTitle{42nd Conference on Very Important Topics (CVIT 2016)}
\EventShortTitle{CVIT 2016}
\EventAcronym{CVIT}
\EventYear{2016}
\EventDate{December 24--27, 2016}
\EventLocation{Little Whinging, United Kingdom}
\EventLogo{}
\SeriesVolume{42}
\ArticleNo{23}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\hideLIPIcs

\begin{document}

\maketitle

%TODO mandatory: add short abstract of the document
\begin{abstract}
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Praesent convallis orci arcu, eu mollis dolor. Aliquam eleifend suscipit lacinia. Maecenas quam mi, porta ut lacinia sed, convallis ac dui. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse potenti.
\end{abstract}

Fast routing in huge street networks has seen a lot of research \cite{Survey}.
For static, time- and user-invariant networks a lot of techniques exist. 
One of the most successful ones are Contraction Hierarchies~\cite{CH}.
These work in two phases.
The first phase is called preprocessing phase and is a slow index-construction.
In this phase the road graph and the edge weights are known.
In the second phase, called query phase, minimum weight paths are computed.
The query phase has access to the precomputed index and is very fast.
Queries can be answered on the order of only a millisecond by CH.

These techniques are used in online navigation services. 
In these services, there is a single index.
With this index a large number of user requests are answered.
The preprocessing phases is rerun on a regular interval to incorporate map updates.

While highly scalable, this setup has the disadvantage, that every user must have use the same weights.
In this paper, we explore an novel algorithm, called CH-Potentials, that uses the two phase setup, however, allows the weights to be modified on a per query basis.
Applications for this algorithm are personalized user settings such as for example:
Avoiding highways, capping the maximum speed, or avoid user-configurable areas.

\paragraph{Related Work}

We are not the first to investigate this problem setting. 
Two approaches exist in the litrature.

The three phase approach splits the preprocessing phase into two.
Techniques that use this setup are MLD/CRP \cite{?} and CCH \cite{?}.
The first phase is a weight-independent preprocessing phase that analsyse the graph topology.
The second phase is called customization phase and introduces the weights into the index.
The third phase is the query phase that computes paths.
The preprocessing phase is very slow.
The customization phase runs on the order of seconds.
The query phase runs within milliseconds.

The three phase approach is ideal to incorporate weight changes that apply to all users.
Live traffic information is a prime example.
It has been sugested to use the three phase approach to handle user-specific requirements by storing a copy of the index per user.
The problem with this approach is that it binds a lot of server-side resources per user.
Further, if the user often changes his weights, the customization needs to run often.
Every customization requires seconds of running time.
Just applying Dijkstra's algorithm to the input graph results in similar running times.

The second approach is Sabine's VLDB personalized routing.
Also TopoCore~\cite{?}.

A paragraph about A*~\cite{?}.

A paragraph about PHAST~\cite{?}.

\paragraph{CH-Potential Overview}

Our novel algroithm CH-Potentials is at its core a combination of A* and PHAST.
For an additional performance, we further combine it with TopoCore.

The input of the preprocessing phase is a graph and lower-bound weights $w_{\ell}$.
Denote by $d_{\ell}(x,y)$ the minimum weight $xy$-path distance with respect to $w_{\ell}$.
The preprocessing phase consists of computing a CH.

The input to the query phase is a source $s$ and a target $t$ node and user-specific weights $w_u$.
These weights $w_u$ must not be smaller than the lower-bound weights $w_{\ell}$, i.e., $w_{\ell}(e) < w_u(e)$ for all edges $e$.
Analogous to $d_{\ell}(x,y)$, $d_u(x,y)$ is the minimum-weight phase according to $w_u$.
The core of the query phase is an A* search with respect to $d_u$ from $s$ to $t$.
The distance $d_{\ell}(x,t)$ from a node $x$ to $t$ is used as potential.

\begin{algorithm2e}
\KwData{$B[x]$ distance from $s$ to $x$ compute in backward search, or $+\infty$ if unreachable}
\KwData{$P[x]$ memoized potential for $x$, or $\bot$ if not yet computed. Equal to $d_{\ell}(x,t)$}
\SetKwFunction{Pot}{Potential}
\SetKwProg{Fn}{Function}{:}{}
\Fn{\Pot{$x$}}{
  \If{$P[x] = \bot$}{
    $P[x]\leftarrow B[x]$\;
    \For{$(x,y)$ is upward CH edge with weight $w_{xy}$}{
      $P[x]\leftarrow \min\{P[x],w_{xy}+\Pot(y)\}$\;
    }
  }
  \Return{$P[x]$}\;
}

\caption{Algorithm to compute Potentials.}
\label{algo:pot}

\end{algorithm2e}


The core contribution of our algorithm consist in the way $d_{\ell}(x,t)$ is efficiently computed.
For this, we use a PHAST variant.
In the first step, we explore all nodes backward-reachable from $t$ in the CH.
We store the computed distances in the array $B$.
We then execute the A* search.
Potentials are computed recursively, on-the-fly, with memoization as depicted in Algorithm \ref{algo:pot}.
If a potential is unknown, it is computed by recursively computing the potentials of all higher nodes in the CH backward search graph.
These potentials are then increased by the distance in the CH backwards search graph.
The potential of a node $x$ is the minimum over all these values and the distance found in the CH forward search.

Our algorithm can be applied as described to the input graph.
However, depending on the weights, the A* search can get stuck often in deadends.
We therefore first coarsen the input graph using TopoCore and apply the above described algorithm to the core.
In this setup, TopoCore handles all deadends. 

\section{Introduction}
\label{sec:intro}

\section{Preliminaries}
\label{sec:prelim}

\section{Perfect Potentials}
\label{sec:algo}

\section{Applications}
\label{sec:applications}

\subsection{Live Traffic}
\subsection{Time-dependent Routing}

\section{Experiments}
\label{sec:exp}

\section{Conclusion}
\label{sec:conclusion}

%%
%% Bibliography
%%

%% Please use bibtex,

\bibliography{references}

% \appendix

\end{document}
