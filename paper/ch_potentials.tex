
\documentclass[a4paper,UKenglish,cleveref, autoref]{lipics-v2019}
%This is a template for producing LIPIcs articles.
%See lipics-manual.pdf for further information.
%for A4 paper format use option "a4paper", for US-letter use option "letterpaper"
%for british hyphenation rules use option "UKenglish", for american hyphenation rules use option "USenglish"
%for section-numbered lemmas etc., use "numberwithinsect"
%for enabling cleveref support, use "cleveref"
%for enabling cleveref support, use "autoref"

\usepackage[algo2e,vlined]{algorithm2e}

%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

\bibliographystyle{plainurl}% the mandatory bibstyle

\title{A* with Perfect Potentials} %TODO Please add

% \titlerunning{Dummy short title}%optional, please use if title is longer than one line

\author{Ben Strasser}{Germany}{academia@ben-strasser.net}{TODO}{}%TODO mandatory, please use full name; only 1 author per \author macro; first two parameters are mandatory, other parameters can be empty. Please provide at least the name of the affiliation and the country. The full address is optional

\author{Tim Zeitz}{Institute of Theoretical Informatics, Algorithmics I, Karlsruhe Institute of Technology, Germany}{tim.zeitz@kit.edu}{}{}

\authorrunning{B. Strasser and T. Zeitz}%TODO mandatory. First: Use abbreviated first/middle names. Second (only in severe cases): Use first author plus 'et al.'

\Copyright{Ben Strasser and Tim Zeitz}%TODO mandatory, please use full first names. LIPIcs license is "CC-BY";  http://creativecommons.org/licenses/by/3.0/

\ccsdesc[500]{Theory of computation~Shortest paths}
% \ccsdesc[500]{General and reference}%TODO mandatory: Please choose ACM 2012 classifications from https://dl.acm.org/ccs/ccs_flat.cfm

\keywords{shortest path, road graphs, goal-directed search, contraction hierarchy}%TODO mandatory; please add comma-separated list of keywords

% \category{}%optional, e.g. invited paper

% \relatedversion{}%optional, e.g. full version hosted on arXiv, HAL, or other respository/website
%\relatedversion{A full version of the paper is available at \url{...}.}

% \supplement{}%optional, e.g. related research data, source code, ... hosted on a repository like zenodo, figshare, GitHub, ...

%\funding{(Optional) general funding statement \dots}%optional, to capture a funding statement, which applies to all authors. Please enter author specific funding statements as fifth argument of the \author macro.

% \acknowledgements{I want to thank \dots}%optional

%\nolinenumbers %uncomment to disable line numbering

%\hideLIPIcs  %uncomment to remove references to LIPIcs series (logo, DOI, ...), e.g. when preparing a pre-final version to be uploaded to arXiv or another public repository

%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \EventEditors{John Q. Open and Joan R. Access}
% \EventNoEds{2}
% \EventLongTitle{42nd Conference on Very Important Topics (CVIT 2016)}
% \EventShortTitle{CVIT 2016}
% \EventAcronym{CVIT}
% \EventYear{2016}
% \EventDate{December 24--27, 2016}
% \EventLocation{Little Whinging, United Kingdom}
% \EventLogo{}
% \SeriesVolume{42}
% \ArticleNo{23}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\hideLIPIcs
\nolinenumbers

\begin{document}

\maketitle

\begin{abstract}
Efficiently computing flexible and optimal routes in continental-sized road networks is a thought challenge.
While Dijkstra's algorithm can be used to solve these problems, it is too slow for many practical problems.
A* is the classical approach to accelerate Dijkstra's algorithm used in many fields such as Experimental Algorithms, Robotics, or Artificial Intelligence.
However, A*'s performance depends on the availability of a good potential, also called heuristic, function.
Computing a good potential is a challenge of its own.
In the past decade, many hierachical speedup techniques have therefore been developped.
They achieve speed and optimality but sacrifize flexibility.
In this paper, we use hierarchical techniques to compute potential functions.
With this approach, we combine some of the hierarchical speed with the flexibility offered by A* - the best of both worlds - while retaining optimality.
\end{abstract}

\section{Introduction}
\label{sec:intro}
Route planning in street networks of continental scale is a well-researched topic with many applications~\cite{bdgmpsww-rptn-16}.
It is usually formalized as a variant of the classical shortest path problem in weighted graphs.
Efficiently computing flexible and optimal routes is a thought challenge.
Optimal means that the computed path always has minimum cost.
Being able to change the edge weights is flexibility.
Efficiently means that the path computation is fast.

Dijkstra's algorithm \cite{?} achieves flexiblity and optimality but unfortunately runs for several seconds on continental road networks, which is too slow for many applications.
A classic speedup approach is the well-known A* algorithm \cite{hnr-afbhd-68}.
While flexible, A*'s performance crucially depends on the quality of the potential or heuristic function.
Finding such a function is difficult.
A lot of research of the last decade has therefore focused on mostly hierarchical approaches \cite{CH,CCH,CRP,HIGHWAYHIERACHIES,MLD} which do not require such a function.
A popular hierachical algorithm is Contraction Hierarchy (CH) \cite{?} and its Live-Traffic capable Customizable CH (CCH) \cite{?} extension.
While undoubtedly fast, hierarchical approaches sacrifice flexibility to obtain speed.
In this paper, we explore CH-Potentials, a novel combination of A* and the hierachical techniques CH and CCH.

Our algorithm is built upon ideas from Phast \cite{?}, a CH-extension.
The novel idea is to compute optimal A* potentials lazily.
The hierarchical approach is applied to the lower bound graph with respect to the edge costs.
As the hierarchical approaches are optimal, the resulting A* potential is the tightest possible.
With this approach, we combine some of the hierarchical speed with the flexibility offered by A* - the best of both worlds - while retaining optimality.

TODO: Cite Sabine

Our technique can be applied to a CH and a CCH.
We describe our work mostly in CH terms.
Fortunately, all results are also directly applicable to CCH.
We describe the trade-off between the two variants in Section \ref{TODO}.


\section{Applications - or why do we care about Flexibility?}




\section{Outline}

\section{Flexible Two-Phase Problem Formulation}

Route planning algorithms usually operate in two or more phases.
The setup details vary among papers as different problem formulations are considered.
In this section, we describe the setup used in our work.

We consider two phases: a preprocessing and a query phase.
In a slow, offline \emph{preprocessing} phase, a graph $G$ with nodes $V$ and edges $E$ is given with \emph{lower bound edge weights} $w_\ell : E\rightarrow \mathbb{R}^+$.
In this phase, auxilary data is computed which is used in a second, fast query phase.

The input to the \emph{query phase} is a start or \emph{source node} $s$ and a destination or \emph{target node} $t$.
Further, the input to the preprocessing phase and the computed auxilary data is available.
Finally, a \emph{query weight function} $w:E\rightarrow \mathbb{R}^+$ is part of the query input.
It must hold that $w_\ell(e) \le w(e)$ for all edges $e$.
The output of the query phase is a path such that the sum over all $w$-weights is minimum.

Variations of this setup exist.
A very common assumption is that the query edge weights $w$ are known during the preprocessing phase.
This allows for very fast query running times, however, changing $w$ requires rerunning the slow preprocessing phase.
This setup is therefore very unflexible.
Many hierarchical speedup techniques such as CH use this setup.
Notable exceptions are \cite{MLD,CRP} and \cite{CCH} which use a third phase to change the query edge weights.

\section{A*}

A* star is a well-known extension to Dijkstra's algorithm.
It uses a potential $\pi:V\rightarrow \mathbb{R}^+$.
The potential is often called heuristic.
A* is optimal, if the potential $\pi(v)$ is consistent \cite{Pearl, Judea (1984). Heuristics: Intelligent Search Strategies for Computer Problem Solving. Addison-Wesley. ISBN 0-201-05594-5.}, which essentially mean that $\pi(v)$ is a lower bound of the distance from $v$ to $t$.

The best possible potential that can be derived from the auxilary data is the minimum path distance with respect to $w_\ell$.
Every better, optimal potential requires knowledge of the query weights $w$.
Our technique allows to compute these best possible potentials.
Within this regard, CH-potentials are optimal.

\section{CH}

\begin{algorithm2e}
\KwData{$B[x]$ tentative distance from $x$ to $t$, initially $+\infty$}
\KwData{Mininum priority queue $Q$, also called open list, initially empty}
Add $t$ to $Q$ with weight 0\;
$B[t] \leftarrow 0$\;
\While{not $Q$ empty}{
	$y\leftarrow$ pop minimum element from $Q$\;
	\For{$xy$ is down-edge in $G^+$}{
		\If{$B[x] > w_\ell(xy) + B[y]$}{
			$B[x]\leftarrow w_\ell(xy) + B[y]$\;
			\eIf{not $x$ in $Q$}{
				Add $x$ to $Q$ with weight $w_\ell(xy) + B[y]$\;
			}{
				Decrease weight of $x$ in $Q$ to $w_\ell(xy) + B[y]$\;
			}
		}
	}
}
\caption{CH backward search}
\label{algo:ch-backward}
\end{algorithm2e}

A CH is a two phase technique to efficiently compute optimal, shortest paths.
For a detailed exposition, we refer the interested reader to \cite{CCH, CH}.
In this section, we give a high-level overview of the aspects relvant to this paper.

A CH places nodes into levels.
No edge must connect two nodes within one level.
Levels are ordered by ``importance''.
An edge goes up when it goes from a node in a lower level to higher level.
Down edges are defined analogously.
An up-down path is a path where only one node $v$ is more important than its neighbors.
$v$ is called the \emph{mid} node.

In the preprocessing phase, a CH adds shortcut edges to the input graph $G$ to obtain $G^+$.
The trick is that in $G^+$ for pair of nodes $s$ and $t$ there exists a shortest up-down $st$-path.
We may therefore restrict our search to up-down paths.
This is done using a bidirectional search.
The forward search starts from $s$ and only follows up-edges.
Similarily, the backward search starts at $d$ and only follows down-edges in reversed direction.
The two searches meet in the mid node.
Pseudo-code for the backward search is presented in Listing~\ref{algo:ch-backward}.
The forward search works analogously.

A CH query is fast, if the number of nodes reachable via only up- or down-nodes is small.
On road networks, this is the case.

Using a CH, we directly obtain a basic CH-potential implementation.
We compute a CH with the lower bound edge weights $w_\ell$ in the preprocessing phase.
In the query phase, we run a classical $A^*$ search and execute in each potential function evaluation a CH query.

This works, however, while one CH query is fast, answering one for every node in the $A^*$ is slow.
Fortunatly, we can do better.
However, for this we need another component called Phast \cite{Phast}.

\section{Phast}

\begin{algorithm2e}
\KwData{$P[x]$ tentative distance from $x$ to $t$}
Execute Algorithm~\ref{algo:ch-backward}\;
\For{all CH levels $L$ from most to least important}{
	\For{all up edges $xy$ in $G^+$ with $x$ in $L$}{
		\If{$P[x] < P[y] + w_\ell(xy)$}{
			$P[x] \leftarrow P[y] + w_\ell(xy)$\;
		}
	}
}
\caption{Phast basic all-to-one search}
\label{algo:phast}
\end{algorithm2e}

Phast \cite{Phast} is a CH extension that computes distances from all nodes to one target node.
It works in two steps.
The first step is analogously to the CH query:
From the target node $t$, all reachable nodes via reversed down-edges are explored.
The second step iterates over all CH level from top to bottom.
In each iteration, all up-edges starting within the current level are followed in reverse.
After all level are processed, the distances from all nodes towards $t$ is computed.
Phast is faster than Dijkstra's algorithm on road graphs because Phast is a better fit for modern processor architecutres.
We refer to \cite{Phast} for an in-depth experimental performance analysis.
Pseudo-code is provided in Listing~\ref{algo:phast}.

Using Phast, we can build another basic CH-potential version.
In the query phase, we first use Phast to compute the distances from every node to $t$ with respect to the query edge weights $w_\ell$ and store the result in an array $H$.
In the next step, we run $A^*$ and implement the potential function as lookup in the array $H$.

This setup also works.
The potential evaluation and by extension the $A^*$ search is indeed fast.
However, Phast step before the search is comparatively expensive.
The reason for this is that the distance from all nodes towards $t$ are computed.
Ideally, we only want to compute the distances from the nodes explored in the $A^*$ search towards $t$.

\section{CH-Potentials}

\begin{algorithm2e}
\KwData{$B[x]$ tentative distance from $x$ to $t$ as computed by Algorithm~\ref{algo:ch-backward}}
\KwData{$P[x]$ memoized potential at $x$, $\bot$ if uncomputed}
\SetKwFunction{Pot}{Potential}
\SetKwProg{Fn}{Function}{:}{}
\Fn{\Pot{$x$}}{
	\If{$P[x] = \bot$}{
		$P[x]\leftarrow B[x]$\;
		\For{all up edges $xy$ in $G^+$}{
			\If{$P[x] > w_\ell(xy)+\Pot(y)$}{
				$P[x] \leftarrow w_\ell(xy)+\Pot(y)$\;
			}
		}
	}
	\Return{$P[x]$}\;
}
\caption{CH-Potentials Algorithm}
\label{algo:pot}
\end{algorithm2e}

Fortunately, the Phast computation can be done lazily using memoization as depicted in Listing~\ref{algo:pot}.
If a potential is unknown, it is computed by recursively computing the potentials of all higher nodes reachable via up-edges in $G^+$.
The computed potentials are then increased by the distance of the corresponding up-edge in $G^+$.
The potential of a node $x$ is the minimum over all these values and the distance found in the CH backward search.

\section{TopoCore}





TODO: Below is old

Fast routing in huge street networks has seen a lot of research \cite{bdgmpsww-rptn-16}.
For static, time- and user-invariant networks a lot of techniques exist.
They work in two phases.
The first phase is called preprocessing phase and is a slow index-construction.
In this phase the road graph and the edge weights are known.
In the second phase, called query phase, minimum weight paths are computed.
The query phase has access to the precomputed index and is very fast.

One of the most successful ones are Contraction Hierarchies~(CH)~\cite{gssv-erlrn-12}.
Contraction Hierarchies exploit inherent hierarchies in the shortest-path structure of road networks.
Using CHs, Queries can be answered on the order of only a millisecond.
However, CHs can not always be easily extended to more complicated problem settings.
% TODO what problem settings
While such extensions exist~\cite{dsw-cch-15,bgsv-mtdtt-13}, they often require substantial engineering effort.

On the other hand, goal directed speed-up techniques based on A* are usually slower but more flexible.
The performance of these approaches depends on the quality of the potential functions used for the A* search.
In this paper, we propose an algorithm which utilizes Contraction Hierarchies to efficiently calculate perfect (best possible) potentials.
This allows us to retain the flexibility of A* based approaches but use much more effective potentials than previously possible.
% These techniques are used in online navigation services.
% In these services, there is a single index.
% With this index a large number of user requests are answered.
% The preprocessing phases is rerun on a regular interval to incorporate map updates.

% While highly scalable, this setup has the disadvantage, that every user must have use the same weights.
% In this paper, we explore an novel algorithm, called CH-Potentials, that uses the two phase setup, however, allows the weights to be modified on a per query basis.
% Applications for this algorithm are personalized user settings such as for example:
% Avoiding highways, capping the maximum speed, or avoid user-configurable areas.

\paragraph*{Related Work}

% We are not the first to investigate this problem setting.
% Two approaches exist in the literature.

% The three phase approach splits the preprocessing phase into two.
% Techniques that use this setup are MLD/CRP \cite{?} and CCH \cite{?}.
% The first phase is a weight-independent preprocessing phase that analsyse the graph topology.
% The second phase is called customization phase and introduces the weights into the index.
% The third phase is the query phase that computes paths.
% The preprocessing phase is very slow.
% The customization phase runs on the order of seconds.
% The query phase runs within milliseconds.

% The three phase approach is ideal to incorporate weight changes that apply to all users.
% Live traffic information is a prime example.
% It has been suggested to use the three phase approach to handle user-specific requirements by storing a copy of the index per user.
% The problem with this approach is that it binds a lot of server-side resources per user.
% Further, if the user often changes his weights, the customization needs to run often.
% Every customization requires seconds of running time.
% Just applying Dijkstra's algorithm to the input graph results in similar running times.

% The second approach is Sabine's VLDB personalized routing.
% Also TopoCore~\cite{?}.

A plethora of of research exists in the area of efficient routing in road networks \cite{bdgmpsww-rptn-16}.
Here, we focus on the algorithms directly relevant to this work.

At the core is the algorithm of Dijkstra~\cite{d-ntpcg-59}.
This algorithm explores the graph visiting nodes ordered by increasing distance from a source node $s$.
For each node $v$, a tentative distance $d_s(v)$ is maintained, which is initially set to $\infty$.
In each iteration the node $u$ with the smallest remaining distance $d_s(u)$ is extracted from a priority queue and settled.
For outgoing edge $(u,v)$ of $u$ the algorithms checks if $d_s(u) + w(u,v) < d_s(v)$.
If so, the distance and the queue position of $v$ is updated.
This process is denoted as edge relaxation.
Once the target node $t$ is settled, the shortest path and distance between $s$ and $t$ is known.

A*~\cite{hnr-afbhd-68} extends Dijkstra's algorithm by changing the order in which nodes are visited.
Nodes in the direction of $t$ should be visited earlier.
This is achieved through a potential function $p$ estimating the distance to $t$.
The priority queue is ordered by $d_s(u) + p(u)$.

ALT~\cite{gh-cspas-05} is an A* based technique which precomputes shortest distances between a small set of landmark nodes and all other nodes during preprocessing.
For the query, potentials are calculated using the triangle inequality for shortest distances and the precomputed distances.
This achieves decent speed-ups and can be used in other problem settings.
However, the performance is not competitive to hierarchical approaches.

Contraction Hierarchies~\cite{gssv-erlrn-12} are a popular hierarchical speed-up technique.
During preprocessing, all nodes are ranked by some measure of importance.
Nodes which lie on many shortest paths are important.
Then, nodes are contracted iteratively by increasing rank.
To contract a node $v$ means removing it form the graph, but preserving shortest distances among all other nodes.
This is achieved by inserting shortcut edges between the neighbors of $v$ which have the length of the path over $v$.
The query is a bidirectional Dijkstra starting from $s$ and $t$ where only edges to higher ranked nodes are relaxed.

PHAST~\cite{dgnw-phast-13} is an algorithm for one-to-many queries based on Contraction Hierarchies.
The preprocessing phase remains the same.
The query begins with a forward upward search from $s$.
The backward search now needs to determine distances to \emph{all} nodes.
To achieve this, PHAST relaxes all edges $(u,v)$ in the backward graph where $rank(u) > rank(v)$ ordered descending by $rank(v)$.
Having processed all edges, distances to all nodes are known.
PHAST achieves good running times by heavily exploiting memory locality:
Nodes and edges are reordered such that relaxing all downward edges is just a linear sweep over the edge array.

% \section{Preliminaries}
% \label{sec:prelim}

\section{Perfect Potentials}
\label{sec:algo}

Our new algorithm is at its core a combination of A* and PHAST.
We take the preprocessing from CHs and PHAST and apply it to a lower bound graph.
The query is an A* variant.
It uses exact distances on the lower bound graph as potentials and obtains these through a lazy PHAST-like approach.
% For an additional performance, we further combine it with TopoCore.


The input of the preprocessing phase is a graph and lower-bound weights $w_{\ell}$.
Denote by $d_{\ell}(x,y)$ the minimum weight $xy$-path distance with respect to $w_{\ell}$.
How exactly this lower bound graph is obtained depends on the problem setting.
In the case of routing with life traffic it may be the free flow travel time.
In the case of time-dependent routing it may be the lower bound of each travel time function.
The preprocessing phase consists of computing a CH of the graph with lower-bound weights.

The input to the query phase is a source $s$ and a target $t$ node and weights $w_u$.
These weights $w_u$ must not be smaller than the lower-bound weights $w_{\ell}$, i.e., $w_{\ell}(e) < w_u(e)$ for all edges $e$.
The weights may be time-dependent travel time predictions, incorporate live traffic or user specific preferences.
Analogous to $d_{\ell}(x,y)$, $d_u(x,y)$ is the minimum-weight phase according to $w_u$.
We obtain $d_u(x,y)$ through an A* search with respect to $d_u$ from $s$ to $t$.
The distance $d_{\ell}(x,t)$ from a node $x$ to $t$ is used as potential.

\begin{algorithm2e}
\KwData{$B[x]$ distance from $s$ to $x$ compute in backward search, or $+\infty$ if unreachable}
\KwData{$P[x]$ memoized potential for $x$, or $\bot$ if not yet computed. Equal to $d_{\ell}(x,t)$}
\SetKwFunction{Pot}{Potential}
\SetKwProg{Fn}{Function}{:}{}
\Fn{\Pot{$x$}}{
  \If{$P[x] = \bot$}{
    $P[x]\leftarrow B[x]$\;
    \For{$(x,y)$ is upward CH edge with weight $w_{xy}$}{
      $P[x]\leftarrow \min\{P[x],w_{xy}+\Pot(y)\}$\;
    }
  }
  \Return{$P[x]$}\;
}

\caption{Algorithm to compute Potentials.}
\label{algo:pot}

\end{algorithm2e}

Our core contribution consist in the way $d_{\ell}(x,t)$ is efficiently computed.
For this, we use a PHAST variant.
Before starting the A* search, we explore all nodes backward-reachable from $t$ in the CH.
We store the computed distances in the array $B$.
We then execute the A* search.
Potentials are computed recursively, on-the-fly, with memoization as depicted in Algorithm \ref{algo:pot}.
If a potential is unknown, it is computed by recursively computing the potentials of all higher nodes in the CH backward search graph.
These potentials are then increased by the distance in the CH backwards search graph.
The potential of a node $x$ is the minimum over all these values and the distance found in the CH forward search.

% Our algorithm can be applied as described to the input graph.
% However, depending on the weights, the A* search can get stuck often in deadends.
% We therefore first coarsen the input graph using TopoCore and apply the above described algorithm to the core.
% In this setup, TopoCore handles all deadends.

% \section{Applications}
% \label{sec:applications}

% \subsection{Live Traffic}
% \subsection{Time-dependent Routing}

% \section{Experiments}
% \label{sec:exp}

\section{Conclusion}
\label{sec:conclusion}

We introduce a novel way to compute potentials for A*.
The potentials are calculated utilizing a CH on a lower bound graph and perfect with regards to that lower bound graph.
With these potentials we can speed up A* search for extended route planning problems like route planning with live traffic, time-dependent travel time predictions or user preferences.

%%
%% Bibliography
%%

%% Please use bibtex,

\bibliography{references}

% \appendix

\end{document}
