\def\year{2021}\relax
\documentclass[letterpaper]{article} % DO NOT CHANGE THIS
\usepackage{aaai20}  % DO NOT CHANGE THIS
\usepackage{times}  % DO NOT CHANGE THIS
\usepackage{helvet} % DO NOT CHANGE THIS
\usepackage{courier}  % DO NOT CHANGE THIS
\usepackage[hyphens]{url}  % DO NOT CHANGE THIS
\usepackage{graphicx} % DO NOT CHANGE THIS
\urlstyle{rm} % DO NOT CHANGE THIS
\def\UrlFont{\rm}  % DO NOT CHANGE THIS
\usepackage{graphicx}  % DO NOT CHANGE THIS
\frenchspacing  % DO NOT CHANGE THIS
\setlength{\pdfpagewidth}{8.5in}  % DO NOT CHANGE THIS
\setlength{\pdfpageheight}{11in}  % DO NOT CHANGE THIS

\usepackage{amssymb}
\usepackage{amsmath}

\setcounter{secnumdepth}{1} %May be changed to 1 or 2 if section numbers are desired.



%This is a template for producing LIPIcs articles.
%See lipics-manual.pdf for further information.
%for A4 paper format use option "a4paper", for US-letter use option "letterpaper"
%for british hyphenation rules use option "UKenglish", for american hyphenation rules use option "USenglish"
%for section-numbered lemmas etc., use "numberwithinsect"
%for enabling cleveref support, use "cleveref"
%for enabling cleveref support, use "autoref"


\usepackage{booktabs}
\usepackage[algo2e,vlined]{algorithm2e}

\pdfinfo{
/Title (A* with Perfect Heuristic/Potentials in Road Networks)
/Author (Ben Strasser, Tim Zeitz)
/Keywords (shortest path, road graphs, goal-directed search, contraction hierarchy, heuristic search)
}
\title{A* with Perfect Heuristic/Potentials in Road Networks}
\author{Ben Strasser\\
academia@ben-strasser.net\\
\And
Tim Zeitz\\
tim.zeitz@kit.edu\\
Karlsruhe Institute of Technology
}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
%\author{
%Ben Strasser


%\author{Tim Zeitz}
%tim.zeitz@kit.edu}
%\affiliation{%
%  \institution{Institute of Theoretical Informatics, Algorithmics I, Karlsruhe Institute of Technology}
%  \city{Karlsruhe}
%  \country{Germany}
%}


\begin{document}

\maketitle

%%
%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more concise list
%% of authors' names for this purpose.
% \renewcommand{\shortauthors}{Strasser and Zeitz}

%%
%% The abstract is a short summary of the work to be presented in the
%% article.
\begin{abstract}
Efficiently computing flexible and optimal routes in continental-sized road networks is a tough challenge.
While Dijkstra's algorithm can be used to solve these problems, it is too slow for many practical applications.
A* is the classical approach to accelerate Dijkstra's algorithm and is used in many fields such as Experimental Algorithms, Robotics, and Artificial Intelligence.
However, A*'s performance depends on the availability of a good heuristic, also called potential, function.
Computing a good heuristic/potential is a challenge of its own.
To avoid the need for a heuristic/potential, many hierarchical speedup techniques, such as Contraction Hierarchies (CH), have been developped.
These techniques are not based on A* and therefore do not need a heuristic/potential.
They achieve speed and optimality but sacrifize A*'s flexibility.
In this paper, we use hierarchical techniques to compute heuristic/potential functions.
We call our technique CH-Potential.
Additionally, we describe some A* optimizations to accelerate the processing of low degree nodes, which occur in road networks.
With this approach, we combine some of the hierarchical speed with the flexibility offered by A* - the best of both worlds - while retaining optimality.
\end{abstract}


\section{Introduction}
\label{sec:intro}
Route planning in street networks of continental scale is a well-researched topic with many applications~\cite{bdgmpsww-rptn-16}.
It is usually formalized as a variant of the classical shortest path problem in weighted graphs.
Efficiently computing flexible and optimal routes is a thought challenge.
Optimal means that the computed path always has minimum weight.
Efficiently means that the path computation is fast.
Being able to change the edge weights between path computations is flexibility.

Dijkstra's algorithm \cite{d-ntpcg-59} achieves flexiblity and optimality but unfortunately rrequires several seconds to compute paths across continental road networks, which is too slow for many applications.
A classic speedup approach is the well-known A* algorithm \cite{hnr-afbhd-68}.
While flexible, A*'s performance crucially depends on the quality of the potential, also called heuristic, function.
Finding such a function that can be computed efficiently is difficult.
A lot of research of the last decade has therefore focused on mostly hierarchical approaches \cite{gssv-erlrn-12,dsw-cch-15,dgpw-crprn-13,ss-ehh-12} which do not require such a function.
A popular hierarchical algorithm is Contraction Hierarchy (CH) \cite{gssv-erlrn-12}.
There is a lot of work that extends CH to handle more complex settings.
For example, in \cite{fns-opca-14,gks-rpfof-10} multi-criteria optimization is studied.
In \cite{dsw-cch-15}, CH is modified to support Live-Traffic.
Historic traffic patterns are combined with CH in \cite{swz-sfert-19,bgsv-mtdtt-13,bdpw-dtdrp-16}.
Specialized variants for electric vehicle routing are developped in \cite{bdgwz-sfpcs-19}.
While these works show that it is possible to extend hierarchical approaches, they also show that it is non-trivial.
Further, in every setting the flexibility available at query time is fairly limited and usually encompasses only one very specific setting.

While undoubtedly fast, hierarchical approaches tend to sacrifice flexibility to obtain speed.
In this paper, we explore CH-Potentials, a novel combination of A* and the hierarchical techniques CH and CCH.
We are not the first to combine hierarchical approaches and A* \cite{bdsssw-chgds-10, gkw-blwr-07, bdgwz-sfpcs-19}.
However, past work mostly uses A* to accelerate hierarchical approaches and sacrifzies A*'s felxibility in the process.
Our primary algorithm design objective is to retain A*'s flexibility.

Our algorithm is built upon ideas from Phast \cite{dgnw-phast-13}, a CH-extension.
The novel idea is to compute optimal A* potentials lazily.
The hierarchical approach is applied to the lower bound graph with respect to the edge costs.
As the hierarchical approaches are optimal, the resulting A* potential is the tightest possible.
With this approach, we combine some of the hierarchical speed with the flexibility offered by A* - the best of both worlds - while retaining optimality.
Figure~\ref{img:search-space} depicts an example A* search with CH-Potentials.

\begin{figure}
TODO

\caption{Example search space when TODO: what parametrization?}
\label{img:search-space}
\end{figure}

\subsection{Applications need Flexibility}

Modelling navigation as shortest path problem in graphs with scalar weights is a good but not perfect formalization.
Several important effects are ignored.
In this section, we list a few to motivate why flexibility is important.
In Section~\ref{sec:extensions}, we describe how to handle some with CH-Potentials in detail.
Our argument is a variation of the one made by~\cite{CRP,CCH,DBLP:conf/gis/FunkeS15}.

The travel time across an edge is in general not constant over time.
Live and predicted traffic are examples of how the travel time can change.
Another example are road blockages.
These are usually modelled by setting travel times to infinity.
Some blockage types, such as accidents, are similar to live traffic.
Other blockages such as reversible one-ways, time-dependent turn-restrictions, or seasonal closures are more similar to predicted traffic.

Flexibility is also necessary to account for driver preferences.
For example, common options in navigation devices include avoiding highways or tunnels. 
These requirements are usally modelled by modifying the edge weights and are highly depend on the driver.
Sometimes they even depend on his current mood and might change while driving.
In this paper, we assume that the driver preference is known.
We refer to \cite{DBLP:conf/gis/DellingGGKTW15,DBLP:conf/gis/FunkeLS16} for approaches to learn these requirements.

Trucks are another class of vehicles with diverse and specific needs.
For example, trucks are not allowed in some areas depending on the time of the day.
Some truck carry hazardous materials and are therefore not allowed in some areas because of environmental protection laws.
Once the truck has delivered his goods, he may again pass the area.
Flexibility can also be used to limit the slope and speed of the roads used during routing.

\subsection{Problem Setting}

As detailed in the previous section, the reasons why flexibility is a necessary property of a routing engine are sheer endless.
However, a formal problem specification that encompasses all these options is complex and well beyond the scope of this paper.
For an example of such a formulation, we refer to \cite{kswz-erptd-20} which covers a truck-specific application.
The algorithm presented in \cite{kswz-erptd-20} uses a preliminary version of CH-Potentials.
For simplicity, we limit our exposition to the classical shortest path formulation.
To support algorithm extensions, such as time-dependent routing as descibed in Section \ref{sec:predicted-traffic}, we avoid two operations that are adverse to generalization.
These are:
(1) traversing an input edge in backward direction, and
(2) combining input weights.
Backward traversal is problematic as a weight can depend on the moment that an edge is entered, which is unknown in a backward search.
Combining input weights can be difficult, if the input weights are more complex objects than scalar values.
For example, when considering historic traffic patterns, the input weights are usually functions \cite{citation needed}.

Our algorithm has one major restriction, it requires the presence of an inflexible scalar weight lower bound for every input edge.
The performance of our algorithm depends on this lower bound being close to the actual weight.
Using the trivial lower bound of zero everywhere, CH-Potentials degenerate to a variant of Dijkstra's algorithm.

Throughout this paper, we assume that we are given a directed graph $G$ with nodes $V$ and edges $E$.
Every edge $(x,y)\in E$ has a \emph{tail} node $x$ and a \emph{head} node $y$.
Further, every edge has a lower bound weight $w_\ell:E\rightarrow \mathbb{R}^+$ and a query weight $w_q:E\rightarrow \mathbb{R}^+ \cup \{+\infty\}$.
It must hold that $0\le w_\ell(e)\le w_q(e)$.
We are further given a source node $s$ and a target node $t$.

Our algorithm uses two phases.
The first is a slow \emph{preprocessing phase}, where only $G$ and $w_\ell$ are known.
It computes auxilary data.
The second phase is the \emph{query phase}.
It is given the auxilary data and $G$, $w_\ell$, $w_q$, $s$, and $t$.
The output of the query phase, is a path $e_1,e_2\ldots e_k$ such that $\sum w_q(e_i)$ is minimized.

\subsection{Related Work}

The closest CH-Potential related works are ALT~\cite{gh-cspas-05,DBLP:conf/wea/DellingW07} and CPD-Heursitics~\cite{DBLP:conf/ijcai/BonoGHS19}.
Just as our approach, ALT is A*-based.
ALT computes the potential using landmarks.
The computed potential values are not optimal and thus of lower quality than the optimal ones computed by CH-Potentials.
ALT is therefore slower.

CPD-Heursitics make use of compressed path databases (CPD). 
A CPD can quickly compute the first edge of a shortest path between any two nodes.
In \cite{DBLP:conf/ijcai/BonoGHS19}, a CPD~\cite{DBLP:conf/socs/StrasserHB14} is used to create a potential.
In every potential evaluation, a path to the target is compute, whose length is used as potential.
On a conceptual level, this is very similar to CH-Potentials. 
Fortunately, CH-Potentials do not have to compute a path per evaluation, which makes CH-Potentials faster.
Further, the CPD used has quadratic preprocessing running times.
A CH does not.
This makes CPDs too expensive on large continental road networks.
The computed potential values are also optimal.

As ALT and CPD-Heursitics have a similar structure than CH-Potentials, the extensions described in Section~\ref{sec:extensions} can also be applied to them.
For example, in~\cite{td-alt} it is extended to time-dependent routing.

The handling of low degree nodes in our A* search is a variation of the techniques used in TopoCore~\cite{DBLP:conf/gis/DibbeltSW15}, which is inspired by~\cite{DBLP:journals/pvldb/FunkeNS14}.


TODO: cite \cite{DBLP:journals/tciaig/BaierBHH15} https://ieeexplore.ieee.org/document/6851877

TODO: cite \cite{DBLP:journals/ai/SharonSFS15} https://www.aaai.org/ocs/index.php/AAAI/AAAI12/paper/viewFile/5062/5239

TODO: cite \cite{DBLP:conf/ijcai/0002UJAKK18} https://arxiv.org/abs/1706.02792

\section{Algorithm Description}

A* star is a well-known extension to Dijkstra's algorithm.
It uses a potential function $\pi:V\rightarrow \mathbb{R}^+$.
The potential is often called heuristic.
A* is optimal, if the potential $\pi(v)$ is consistent \cite{p-hissc-84}.
In this paper, all considered potentials are derived from exact shortest path distances and are thus consistent.


The best possible potential that can be derived from the auxilary data is the minimum path distance with respect to $w_\ell$.
Every better, consistent potential requires knowledge of the query weights $w_q$, which is unavailable during preprocessing.
Our technique allows to compute these best possible potentials.
Within this regard, CH-Potentials are \emph{optimal A* potentials}.

\subsection{Contraction Hierarchy (CH)}

\begin{algorithm2e}
\KwData{$B[x]$ tentative distance from $x$ to $t$}
\KwData{Min. priority queue $Q$, also called open list}
$B[x] \leftarrow +\infty$ for all $x\neq t$\;
$B[t] \leftarrow 0$\;
Make $Q$ only contain $t$ with weight $0$\;
\While{not $Q$ empty}{
	$y\leftarrow$ pop minimum element from $Q$\;
	\For{$xy$ is down-edge in $G^+$}{
		\If{$B[x] > w_\ell(xy) + B[y]$}{
			$B[x]\leftarrow w_\ell(xy) + B[y]$\;
			\eIf{not $x$ in $Q$}{
				Add $x$ to $Q$ with weight $w_\ell(xy) + B[y]$\;
			}{
				Decrease weight of $x$ in $Q$ to $w_\ell(xy) + B[y]$\;
			}
		}
	}
}
\caption{CH backward search}
\label{algo:ch-backward}
\end{algorithm2e}

A CH is a two phase technique to efficiently compute optimal, shortest paths.
For a detailed exposition, we refer the interested reader to \cite{dsw-cch-15,gssv-erlrn-12}.
In this section, we give a high-level overview of the aspects relevant to this paper.

A CH places nodes into levels.
No edge must connect two nodes within one level.
Levels are ordered by ``importance''.
The intuition is that dead-ends are unimportant and low while highway bridges are very important and high.
An edge goes \emph{up} when it goes from a node in a lower level to higher level.
\emph{Down} edges are defined analogously.
An \emph{up-down path} is a path where only one node $v$ is more important than its neighbors.
$v$ is called the \emph{mid} node.
An \emph{up path} is a path where the last node is the mid node.
Similarily, the first node is the mid node of a \emph{down path}.
Every up and down path is an up-down path.

In the preprocessing phase, a CH adds \emph{shortcut} edges to the input graph $G$ to obtain $G^+$.
The trick is that in $G^+$ for pair of nodes $s$ and $t$ there exists a shortest up-down $st$-path with the same length as a shortest path in $G$.
We may therefore restrict our search to up-down paths in $G^+$.
This search is bidirectional.
The forward search starts from $s$ and only follows up-edges.
Similarily, the backward search starts at $t$ and only follows down-edges in reversed direction.
The two searches meet in the mid node.
Pseudo-code for the backward search is presented in Algorithm~\ref{algo:ch-backward}.
The forward search works analogously.

A CH query is fast, if the number of nodes reachable via only up- or down-nodes is small.
On road networks, this is the case as demonstrated in \cite{gssv-erlrn-12,dgrw-gpnc-11,dgpw-crprn-13,dsw-cch-15,hs-gbpo-18}.

Using a CH, we can easily compute optimal A* potentials.
In the preprocessing phase, a CH with respect to $w_\ell$ is computed.
The query phase consists of an A* search, where the evaluation of the potential $\pi(v)$ performs a CH-query from $v$ to $t$.

This works, however, while one CH query is fast, answering one for every node in the $A^*$ search is slow.
Fortunatly, we can do better.
However, for this we need another component called Phast \cite{dgnw-phast-13}.

\subsection{Potentials using PHAST}

\begin{algorithm2e}
\KwData{$P[x]$ tentative distance from $x$ to $t$}
Execute Algorithm~\ref{algo:ch-backward}\;
\For{all CH levels $L$ from most to least important}{
	\For{all up edges $xy$ in $G^+$ with $x$ in $L$}{
		\If{$P[x] < P[y] + w_\ell(xy)$}{
			$P[x] \leftarrow P[y] + w_\ell(xy)$\;
		}
	}
}
\caption{Phast basic all-to-one search}
\label{algo:phast}
\end{algorithm2e}

Phast \cite{dgnw-phast-13} is a CH extension that computes distances from all nodes to one target node.
First the preprocessing phase is executed analogously to the original CH.
The query phase is divided into two steps.
The first step is analogously to the CH query:
From the target node $t$, all reachable nodes via reversed down-edges are explored.
Algorithm~\ref{algo:ch-backward} shows this first step.
The second step iterates over all CH level from top to bottom.
In each iteration, all up-edges starting within the current level are followed in reverse.
After all level are processed, the distances from all nodes towards $t$ is computed.
Phast is slightly faster than Dijkstra's algorithm on road graphs because it is a better fit for modern processor architectures.
Phast's main advantage is that is easily be parallelized.
However, we will not consider parallelization in this paper.
We refer to \cite{dgnw-phast-13} for an in-depth experimental performance analysis.
Pseudo-code is provided in Algorithm~\ref{algo:phast}.

Using Phast, we can compute optimal A* potentials in another way.
In the query phase, we first use Phast to compute the distances from every node to $t$ with respect to the query edge weights $w_\ell$ and store the result in an array $H$.
In the next step, we run $A^*$ and implement the potential function as lookup in the array $H$.

This setup also works.
The potential evaluation and by extension the $A^*$ search is indeed fast.
However, the Phast step before the search is comparatively expensive.
The reason for this is that the distance from all nodes towards $t$ are computed.
Ideally, we only want to compute the distances from the nodes explored in the $A^*$ search towards $t$.

\subsection{CH-Potentials}

\begin{algorithm2e}
\KwData{$B[x]$ tentative distance from $x$ to $t$ as computed by Algorithm~\ref{algo:ch-backward}}
\KwData{$P[x]$ memoized potential at $x$, $\bot$ if uncomputed}
\SetKwFunction{Pot}{Potential}
\SetKwProg{Fn}{Function}{:}{}
\Fn{\Pot{$x$}}{
	\If{$P[x] = \bot$}{
		$P[x]\leftarrow B[x]$\;
		\For{all up edges $xy$ in $G^+$}{
			\If{$P[x] > w_\ell(xy)+\Pot(y)$}{
				$P[x] \leftarrow w_\ell(xy)+\Pot(y)$\;
			}
		}
	}
	\Return{$P[x]$}\;
}
\caption{CH-Potentials Algorithm}
\label{algo:pot}
\end{algorithm2e}

Fortunately, the Phast computation can be done lazily using memoization as depicted in Algorithm~\ref{algo:pot}.

In a first step, we run the backward CH search from $t$ to obtain an array $B$.
$B[v]$ is the minimum down $vt$-path distance or $+\infty$, if there is no such path.
$B$ is computed as shown in Algorithm~\ref{algo:ch-backward}.

Suppose, we need to compute the potential $\pi(v)$ of a node $v$.
We do this by first recursively computing the potentials $\pi(u)$ of all nodes for which an up-edge $(v,u)$ exists.
Afterwards, we compute using $\min_u\{w_\ell(v,u) + \pi(u)\}$ the minimum distance over all up-down paths that contain at least one up-edge.
As the minimum distance up-down path does not necessarily have to contain an up-edge, we set $\pi(v) = \min \{ B[v], \min_u\{w_\ell(v,u) + \pi(u)\} \}$.
This calculation is correct, as it computes the minimum up-down $vt$-path distance in $G^+$, which corresponds to the minimum $vt$-path distance in a CH.

The resulting algorithm is the basic CH-potential algorithm.
It is flexible and optimal and slightly faster than Dijkstra's algorithm.
However, we can still improve the performance.
A quick investigation reveals, that most of the running time is spent in the potential evaluation.
We therefore investigate methods to evaluate fewer potentials.

\subsection{Skip Degree Two Nodes}

Potential evaluation is an expensive operation that we want to avoid.
A potential evaluation is always paired with a queue push operation.
By avoiding push operations, we can therefore avoid potential evaluations.
This is the objective of this and the next section.

We modify how A* by processing low degree nodes consecutively without pushing them into the queue.
Our algorithm makes use of the undirected degree $d(x)$ of a node $x$.
Formally, $d(x)$ is the number of nodes $y$ such that $(x,y)\in E$ or $(y,x)\in E$.

Analogous to A*, our algorithm stores for every node $x$ a tentative distance $D[x]$.
Additionally, it maintains a minimum priority queue.
Diverging from A*, not all nodes can be pushed but every node has a tentative distance.

Our algorithm differs from A* when removing a node $x$ from the queue.
A* iterates over the outgoing arcs $(x,y)$ of $x$ and tries to reduce $D[y]$ by relaxing $(x,y)$.
If A* succeeds, $y$'s weight in the queue is set to $D[y]+\pi(y)$.
Our algorithm, however, behaves differently, if $d(y)\le 2$.
Our algorithm determines the longest degree two chain of nodes $x,y_1,\ldots, y_k, z$ such that $d(y_i)=2$ and $d(z)\neq z$.
If our algorithm succeeds in reducing $D[y_1]$, it does not push $y_1$ into the queue.
Instead, it iteratively tries to reduce all $D[y_i]$.
If it does not reach $z$, then only $D$ is modified but no queue action is performed.
If $D[z]$ is modified and $d(z)>2$, $z$'s weight in the queue is set to $D[y]+\pi(y)$.

As the target node $t$ might have degree two, our algorithm cannot rely on stopping, when $t$ is removed from the queue.
Instead, our algorithm stops as soon as $D[t]$ is less than the minimum weight in the queue.

\subsection{Skip Degree Three Nodes}

\begin{figure}

\begin{center}
\includegraphics{push-deg3}
\end{center}

\caption{$x$ is removed from the queue. $y_i$, $z$, $a_i$, and $\alpha_i$ are never part of the queue. $\beta$ and $b$ are pushed into the queue.}
\label{fig:push-deg3}

\end{figure}


In the previous section, we described an optimized A* variant that does not push degree two nodes.
In this section, we also avoid degree three nodes.

Denote by $x,y_1,\ldots, y_k, z$ a degree chain as described in the previous section.
If $z$ is already in the queue, then $z$'s weight in the queue is adjusted as in the previous section.

If $d(z)\neq 3$ or $z$ is in the queue, our algorithm proceeds as in the previous section.
Otherwise, there exist up to two degree chains $z,a_1,\ldots,a_p,b$ and $z,\alpha_1,\ldots,\alpha_q,\beta$ such that $a_1\neq y_k \neq \alpha_1$.
Our algorithm iteratively tries to reduce all $D[a_i]$ and $D[\alpha_i]$.
If it reaches $\beta$, $\beta$'s weight in the queue is set to $D[\beta]+\pi(\beta)$.
Analogously, if $b$ is reached, $b$'s weight is set to $D[b]+\pi(b)$.
If $b$ respectively $\beta$ are not reached, our algorithm does nothing.
The situation is depicted in Figure~\ref{fig:push-deg3}.

\subsection{Skip Nodes Outside of Largest Biconnected Component}

\label{sec:largested-biconnected-component}

A lot of nodes in road networks lead to dead-ends.
Unless the source or target is is in a dead-end, it is unnecessary to explore these nodes.
This reduces the number of explored nodes and thus fewer potentials are evaluated.

In the preprocessing phase, before the CH is created, we compute the subgraph $G_C$, called \emph{core}, induced by the largested biconnected component of the undirected graph underlying $G$.
We do this using Tarjan's algorithm \cite{t-dfslg2-72}.
For every node $v$ in the input graph $G$, we store the attachment node $a_v$ to the core.
For nodes in the core, $a_v=v$.
We exploit that all attachment nodes are single node separators and the problem can be decomposed along them.
The basic CH-potential preprocessing step is only executed for $G_C$.

The query phase is divided into four steps.
In the first step, we use Dijkstra's algorithm to explore the component that contains $s$ until $a_s$ is reached.
If this search finds $t$, then $s$ and $t$ are part of the same component.
An optimal path was found and therefore the algorithm stops early.
Otherwise, in the second step starts.
It consits of applying the basic CH-potential algorithm restricted to $G_C$ from $a_s$ to $a_t$.
Finally, in the third step, we search a path from $a_t$ towards $t$ using Dijkstra's algorithm restricted to $t$'s biconnected component.
The final path is the concatenation of all three path parts.

\section{Extensions}
\label{sec:extensions}

A* is a very flexible algorithm. 
Many extended problems can therefore be solved using the CH-Potentials algorithm.
In this section, we describe some extended problems.

\subsection{Avoiding Tunnels and/or Highways}
\label{sec:no-tunnel-highway}

Avoiding tunnels and/or highways is a common feature of navigation devices.
Implementing this feature with CH-Potentials is easy.
We set $w_\ell$ to the freeflow travel time. 
If an edge is a tunnel and/or a highway, we set $w_q$ to $+\infty$.
Otherwise, $w_q$ is also to the freeflow travel time.
This is all that is necessary to make our CH-Potentials algorithm avoid tunnels and/or highways.

\subsection{Forbidden Turns}
\label{sec:no-turns}

The classical shortest path problem allows to turn from every edge to every other incident edge at every node.
However in the real world, turn restrictions, such as a forbidden left or right turn, exist.
Such restrictions are usually modelled using turn weights.
We extend CH-Potentials by using zero as lower bound for every turn weight in the potential.
In this section, we first present the extended problem setting.
Afterwards, we describe how it can be solved with CH-Potentials.

In the extended problem, a \emph{turn weight} $w_t$ is introduced~\cite{related-turn-litrature,see-geisberger-turn-table-paper}.
$w_t$ maps a pair of incident edges onto the time required to perform the turn.
Formally, $w_t$ is a function from $V^3$ to $\mathbb{R}^+ \cup \{+\infty\}$.
A forbidden turn is modelled by setting the corresponding $w_t$ to $+\infty$.

A path with nodes $v_1, v_2,\ldots v_k$ has the following \emph{turn-aware path weight}:\[
w_q(v_1, v_2) + \sum_{i=2}^{k-1}  w_t(v_{i-1},v_i,v_{i+1})  + w_q(v_i,v_{i+1}) 
\] The input to the extended problem consists of a source edge and a target edge.
The objective is to find a path connecting these edges such that the turn-aware path weight is minimized.
The first term $w_q(v_1, v_2)$ only depends on the source edge.
As all considered paths share the same source edge, the term is the same for all paths.
We can therefore ignore it during the optimization.

To account for turns, many algorithms construct a \emph{turn-expanded} graph $G'$.
Edges in the input graph $G$ correspond to \emph{expanded nodes} in $G'$. 
For every pair of successive edges $(x,y)$ and $(y,z)$ in $G$, there is an \emph{expanded edge} in $G'$ with expanded weight $w_t(x,y,z) + w_q(y,z)$.
A sequence of expanded nodes in the expanded graph $G'$ corresponds to a sequence of edges in the input graph $G$.
The weight of a path in $G'$ is equal to the turn-aware weight of the corresponding path in $G$ minus the irrelevant $w_q(v_1,v_2)$ term.
Turn-aware shortest paths can thus be computed by searching for shortest paths in the expanded graph.

The simplest combination of turn-aware routing with CH-Potentials consists of using the expanded graph as input to the CH-Potential algorithm.
However, this implies computing a CH on the expanded graph.
This is feasible but has a number of problems such as higher preprocessing running time, increased memory consumption, or more complex code~\cite{geisberger-turn-table-paper}.
We want to avoid these complications.

We therefore only apply the A* search to the expanded graph $G'$. 
The potentials are computed with respect to the input graph $G$.
Let $(p,q)$ be the target edge and $(x,y)$ the edge for which the A* search wants to compute a potential.
We construct non-turn-aware CH-Potentials towards $q$.
The potential for the edge $(x,y)$ is equal to the potential of $y$.

To prove correctness, consider the turn-aware path weight of an optimal path $v_1,v_2\ldots v_k$ with $v_1=x$, $v_2=y$, $v_{k-1}=p$, and $v_k=q$.
We can lower bound the expression as follows:
\[
\sum_{i=2}^{k-1} w_\ell(v_i,v_{i+1}) \le \sum_{i=2}^{k-1} \underbrace{w_t(v_{i-1},v_i,v_{i+1})}_{0\le} + \sum_{i=2}^{k-1} \underbrace{w_q(v_i,v_{i+1})}_{w_\ell(v_i,v_{i+1})\le}
\]
The $\sum_{i=2}^{k-1} w_\ell(v_i,v_{i+1})$ expression is the length of some, not necessarly shortest, $yq$-path in $G$ with $w_\ell$.
It is by definition not smaller than the shortest $yq$-path length in $G$ with $w_\ell$.
The shortest $yq$-path length is exactly what CH-Potentials compute.
The potential is therefore a lower bound.
It is consistent because it is derived from exact shortest paths in $G$ with $w_\ell$.

Unfortunately, the undirected graph underlying the expanded graph is always biconnected, if the input graph is strongly connected.
The optimization described in \ref{sec:largested-biconnected-component} is therefore ineffective in this setting.

With this setup we extended CH-Potentials in a way that keeps all turn-related information out of the CH.
This allows for a comparatively simple implementation.

\subsection{Predicted Traffic}
\label{sec:predicted-traffic}

The classical shortest path problem assumes that edge weights are scalars. 
However in practice, travel times vary along an edge.
The primary reason is traffic.
Recurring traffic can be predicted by observing the traffic in the past.
It is common \cite{lots-of-td-papers} to represent these predictions as \emph{travel time function}.
An edge weight is no longer a scalar value but a function that maps the entry time onto the traversal time.
Performing this prediction is outside of the scope of this paper.
It is common to refer to routing with predicted traffic as \emph{time-dependent routing}.
Again, we first formalize the extended problem setting and then describe our solution with CH-Potentials.

Formally, $w_q$ is a function from $E\times \mathbb{R}$ to $\mathbb{R}^+$. 
$w_q(e, \tau)$ is the travel time through edge $e$ when entering it at moment $\tau$.
The input to the extended problem consists of a source node $s$ and a target node $t$, as in the classical problem formulation.
Additionally, the input contains a source time $\tau_s$.
A path with edges $e_1,e_2\ldots e_k$ is weighted using $\alpha_k$, which is defined recursively as follows:\[
\begin{split}
\alpha_{1} & = w_q(e_1, \tau_s) \\
\alpha_{k} & = \alpha_{k-1} + w_q(e_1, \alpha_{k-1})
\end{split}
\]
The objective is to find a path that minimizes $\alpha_k$.

If all travel time functions fulfill the \emph{no-waiting property}, this problem can be solved using a straight forward extension of Dijkstra's algorithm \cite{td-alt?}.
The necessary modification to A* is analogous.
Without the no-waiting property the problem is in general NP-hard \cite{veit}.
The no-waiting property states that it is never benficial to wait at a node before entering an edge.
Formally stated, the following must hold:\[
\forall e\in E,\tau\in \mathbb{R},\delta\in \mathbb{R}^+: w_q(e, \tau) \le w_q(e, \tau+\delta) + \delta
\]

Usually, travel time functions are stored as piece-wise linear functions.
Our implementation follows this setup.
However in priciple, our algorithm works with any representation that enables an efficient function evaluation.

To solve the time-dependent routing problem, we employ a stratedgy very similar to TD-ALT~\cite{td-alt}.
The main difference is that we use CH-Potentials instead of landmarks to guide the A* search.
We set $w_\ell(e)$ to the minimum travel time for every edge, i.e., $w_\ell(e) = \min_\tau w_q(e,\tau)$.

We modify the A* search to use the tentative distance at a node $x$ as $\tau$ when evaluating the weight of an outgoing edge $(x,y)$.
This modification is straight-forward, as our optimizations do not use shortcuts and only travers edges in forward direction.
For the correctness proof, we refer to~\cite{td-alt?}.

With this setup, we extended CH-Potentials to support time-dependent routing.
As we were able to keep all travel time functions out of the CH.
This avoids a lot of algorithmic complications compared to~\cite{TD-CH,CatchUp,TD-CRP}, which create shortcuts of travel time functions to combine hierarchical speedup techniques with time-dependent routing.

\subsection{Live and Predicted Traffic}
\label{sec:live-predicted-traffic}

Beside predicted traffic, we also consider live traffic.
Live traffic refers to the current traffic situation.
It is important to distinguish between predicted and live traffic.
The predicted travel time along an edge was estimated in the past.
It is possible that it differes from the current travel time significantly, if unexpected events happen.
An accident is an example of an unexpected event.
Live traffic data is more accurate for the current moment than predicted data.
However, just using live traffic data is problematic for long routes as traffic changes while driving.
At some point, one wants to switch from live traffic back to the predicted traffic.
In this section, we first describe how to use only live traffic and then describe how to combine it with predicted traffic.

To support live traffic, we set $w_\ell$ to the travel time without any congestions.
$w_q$ is set to the travel time accounting for the current traffic.
As traffic only increases the travel time along an edge, $w_\ell$ is a valid lower bound for $w_q$.
With this setup, the CH-Potentials algorithms can make use of live traffic.

To combine live traffic with predicted traffic, we define a modified travel time function.
Denote by $w_p(e,\tau)$ the predicted travel time along edge $e$ at moment $\tau$.
Further, $w_c(e)$ is the travel time according to the live traffic.
Finally, we denote by $\tau_{\mathrm{soon}}$ the moment up to which we trust the live traffic.
In our experiments, we set $\tau_{\mathrm{soon}}$ to one hour in the future.
We need to make sure that the modified travel time function fulfills the no-waiting property.
For this reason, we cannot make a hard switch at $\tau_{\mathrm{soon}}$.
Our modified travel time function linearly approaches the predicted travel time with a bounded slope.

Formally, we set $w_q(e,\tau)$ to $w_c(e)$, if $\tau_{\mathrm{soon}}$.
Otherwise, we check whether $w_p(e,\tau_{\mathrm{soon}}) < w_c(e)$ is true.
If it is the case, we set $w_q(e,\tau)$ to $\max\{w_c(e)+(\tau_{\mathrm{soon}}-\tau), w_p(e,\tau)\}$.
Otherwise, we set $w_q(e,\tau)$ to $\min\{w_c(e)-(\tau_{\mathrm{soon}}-\tau), w_p(e,\tau)\}$.
We set $w_\ell$ again to the freeflow travel time.
Finally, we run the modified time-dependent A* described in the previous section on this modified travel time function. 
In our implementation, we to not modify the representation of $w_p$.
Instead, we evaluate the formulas above each time that the modified travel time function is evaluated.

With this setup, we extended CH-Potentials to support a combination of live and predicted traffic.
We did not make any modification to our algorithm, that would make a combination with tunnel and/or highway avoidance or turn-aware routing difficult.
This straight-forward integration of complex routing problems is the strengh of the CH-Potential algorithm.

\section{Experiments}

\label{sec:experiments}

\begin{figure*}
\centering
\includegraphics[width=\textwidth]{fig/scaled_weights.pdf}
\caption{Query running times for queries of DIMACs Europe with scaled edge weights.}\label{fig:scaled_weights}
\end{figure*}

In this section, we present our experimental evaluation.
Our benchmark machine runs openSUSE Leap 15.1 (kernel 4.12.14), and has 128\,GiB of DDR4-2133 RAM and an Intel Xeon E5-1630 v3 CPUs which has four cores clocked at 3.7\,Ghz and 4~$\times$~32\,KiB of L1, 8~$\times$~256\,KiB of L2, and 10\,MiB of shared L3 cache.
All experiments were performed sequentially.
Our code is written in Rust and compiled with rustc 1.44.0-nightly in the release profile with the target-cpu=native option.

\subparagraph{Inputs and Methodology}
Our main benchmark instance is a graph of the road network of Western Europe made publicly available for the Ninth DIMACS implementation Challenge~\cite{DemetrescuGJ09} with 18M nodes and 42M edges.
We use this graph with the travel time as the lower bound and perform experiments with modified edge weights (scaling all travel times or reproducing an experiment from~\cite{dw-lbrdg-07} where 1\,000 random edges are perturbed).
Additionally, we perform experiments on a recent OSM instance of Germany\footnote{\url{https://download.geofabrik.de/europe/germany.html}, obtained on August 2nd, 2019}.
To obtain the routing graph, we use the import from RoutingKit\footnote{\url{https://github.com/RoutingKit/RoutingKit}}.
The graph has 11M nodes and 26M edges.
For this instance, we have proprietary live traffic snapshot from Friday 2019/08/02 afternoon provided by Mapbox\footnote{\url{https://www.mapbox.com/}}.
The live data comes in the form of 320K OSM node pairs and live speeds for the link between the nodes.
We also have two graphs with traffic predictions provided by PTV\footnote{\url{https://ptvgroup.com}}.
One is an old instance of Germany with traffic predictions from 2006 (4.7M nodes, 10.7M edges) and the other a newer instance of Europe (25.8M nodes, 55.5M edges, from 2017).
Preprocessing running times are averages over 10 runs.
For the queries, we perform 10\,000 point-to-point queries where both source and target are nodes drawn uniformly at random and report average results.

\begin{table*}
\centering
\caption{Query performance with the different algorithmic features.}\label{tab:building_blocks}
\input{table/building_blocks.tex}
\end{table*}

\begin{table*}
\centering
% TODO dijkstra baseline, preprocessing
\caption{Performance for different applications.}\label{tab:applications}
\input{table/applications.tex}
\end{table*}

\section{Conclusion}
\label{sec:conclusion}

We introduce a novel way to compute potentials for A*.
The potentials are calculated utilizing a CH on a lower bound graph and perfect with regards to that lower bound graph.
With these potentials we can speed up A* search for extended route planning problems like route planning with live traffic, time-dependent travel time predictions or user preferences.

%%
%% Bibliography
%%

%% Please use bibtex,

\bibliography{dblp,references}
\bibliographystyle{aaai}
\end{document}
