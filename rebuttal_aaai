We thank all reviewers for their detailed and helpful feedback.

Several question came up on the nature of the query model and w_q, how this enables flexibility and how all of these extensions are a valuable contribution.
Apparently, we failed to communicate that clearly.
This is a weakness in our presentation that we must address.
For the scope of this rebuttal, we hope to clarify it in the following paragraphs.

w_q is implemented as a procedure that takes an edge ID and the edge entry time as parameters.
It computes a weight at query time, which must not be smaller than w_l.
w_q can be arbitrary code as long as it fits this description.
In C++ terms, you can think of w_q as a lambda parameter to the main algorithm which can change for every query.
What w_q does is independent of the main algorithm and depends on the extensions considered:

* For static and live traffic weights, w_q is an array lookup.
* For highway and tunnel avoidance, w_q is an if-else-branch that checks the edge property and returns infinity or the static edge travel time.
* For predicted traffic, w_q evaluates a piecewise linear function.
* In real-world applications, other restrictions may appear. Time-restriction, turn restrictions, seasonal road closures, closures that depend on the hazard level of the load of the vehicle, and more.

The power of CH-Potentials is that these relevant but nasty real-world effects are confined to w_q.
We never need to reason about what happens when trying to construct shortcuts with the above mentioned extensions.
Shortcuts are only constructed on w_l.

Many papers have been written on extending CHs, which use shortcuts.
There is an entire PhD thesis on how predicted traffic interacts with CH shortcuts.
It is a difficult topic.
Changing w_q is trivial in comparison.

This separation of concerns makes supporting extensions (and their combinations) vastly easier than directly extending a CH.
Demonstrating this, and thus proving the flexibility of our approach is the purpose of Section 6.

We know of no paper that managed to combine all presented extensions as direct CH extension.

# Answers to Reviewer 1

> I recommend to compare to [...] [1 (CH Journal)] [...].

For the w_q = w_l case, our algorithm is similar to CH.
CH queries on OSM Ger take 0.163 ms.
We'll add this number to Table 3.
For w_q = w_l, CH-Potentials are at 0.6 s.
Extending CH for w_q != w_l is difficult for the reasons discussed above.

> I am not familiar with CH. A deeper explanation could be useful.

We agree with this but doing so in the given page limit is difficult.

# Answers to Reviewer 2

> This is not really novel, though, as it has been already instrumented in the works by Goldberg et al (even though slightly differently via shortcuts).

There is a major difference between the Core-ALT line of work and CH-Potentials.
Core-ALT contracts parts of the input graph and inserts shortcut edges.
To create these shortcuts, one must reason about how they interact with the extensions used.
For CH-Potentials this is not necessary. 

If you are referring to some other work, please provide a reference. 
We would like to learn about it!

> it would be interesting to see how their approach fares against techniques like CRP or CCH [...]

Our model assumes that the weights change for every query. 
For every query, a customization must thus be executed.
A full, sequential CRP/CCH customization takes seconds.
Partial customization exists but depending on the extensions used would also be slow as too many weights change.
CH-Potentials are way faster than these times.
Further, neither CRP nor CCH support w_q edge entry times.
Predicted traffic is therefore difficult.

# Answers to Reviewer 3

> in Section 6.5, the authors mention a "preliminary version of CH-Potentials."
> But they do not explain how the current submission differs.

There exists an Arxiv preprint version of our paper to claim the idea.
There exists published work that describes a truck specific extension but refers to the Arxiv version for the algorithm.
This submission is the first reviewed paper that describes CH-Potentials in detail.
The truck extension is not described in this submission.

> How is the Oracle-A* implemented?

Oracle-A* is implemented by running each query twice and only measuring the time for the second run.
During the first run, all necessary distances are memoized and accessed in the second run.

> There is not enough comparison to the existing literature.
> For example, the authors dismiss one competing algorithm on the grounds that the "pre-processing is prohibitive" but do not take their approach's pre-processing into account in the results.

Oracle-A* is a lower bound on what is achievable with heuristic-tuning.
We show that we are very close to Oracle-A*.
By extension, no other heuristic-tuning work exists that can significantly outperform CH-Potentials.
Indirectly, this is therefore a comparison with many papers, including ALT and CPD-heuristics.

Our preprocessing running times are reported in Table 1.

The CPD used performs n one-to-all Dijkstra searches during preprocessing.
On OSM Ger such a Dijkstra search takes about 2s.
The graph has 16M nodes.
We estimate a preprocessing time of 370 days.
This is prohibitively long.
To verify our estimation, we obtained their code and started the preprocessing.
We aborted it after 48 h.
CH-Potentials need 5 min.

Ignoring the infeasible preprocessing, their work is subject to the Oracle-A* lower bound.
Solving the preprocessing problem would thus not result in an algorithm outperforming CH-Potentials.

> It seems the algorithm really is: compute a CH, route with A*.
> If so, I do not think it is applicable -- at least efficiently -- to dynamic networks such as those described in Section 6.

All extensions from Section 6 were evaluated in Section 7.
Our experiments clearly show that our algorithm is efficient on large dynamic road networks.

# Answers to Reviewer 4

> There is previous work on such techniques in the heuristic search community, but it doesn't seem to be mentioned.

We do not know what paper you are referring to but want to learn from it.
Please, provide a reference.
We will also cite it.

> [Questions regarding skipping higher degree nodes:]

Our ideas are motivated by the TopoCore paper [2] which touches some of these questions.
For TopoCore, low degree nodes are contracted.
Node skipping is similar to a lazy version of the contractions in TopoCore.
TopoCore does not contract nodes of degree 4 or higher as doing so inserts more edges than it removes.

1. Yes, our methods should work for higher degrees.
2. No, for the same reason as [2].
3. Yes, the effectiveness depends on the number of low degree nodes which is graph specific.

[1] Geisberger; Sanders; Schultes; Vetter 2012. Exact Routing in Large Road Networks Using Contraction Hierarchies. Transportation Science

[2] Dibbelt; Strasser; Wagner 2015. Fast exact shortest path and distance queries on road networks with parametrized costs. SIGSPATIAL 
